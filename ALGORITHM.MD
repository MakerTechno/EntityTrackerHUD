# 目前本项目的投影原理
## 主要步骤
- 准备：Config
- 获取：Config-**目标实体类型**; Config-**对应指针类型**(Enum);
- 获取2：玩家**眼坐标**; 玩家**视向量**;
- 获取3：遍历**已记录**的实体类型列表 -> 在各个方向延伸**64格**内(垂直向下为48格)的所有实体中寻找 -> 记录**新**列表“坐标-指针类型”
- 运算：获得投影角度和投影距离
- 渲染：按运算结果渲染

## 算法概述
### 中心环绕型 
#### 固有转换：经度锁定
- 计算玩家视坐标到目标坐标的位向量(概念上是三维射线的意思)
- 三维变换归一化获得在“单位球壳”上的坐标点
- 计算玩家视线向量(同上，直线)
- 归一化视向量获得视坐标
- 对球壳上两点(玩家视觉点与目标位置点)进行选择的投影，获得平面点
- 求得视坐标投影点->位坐标投影点的弧度、距离

投影类型 
: 墨卡托投影
: 艾托夫投影
: 温克尔三重投影(线性混合)

#### 编写中心环绕型(早期代码)时的思考
在实际应用中发现水平方向存在**“面对实体后向左转91度箭头就由左边变到右边，而右边需要转271度”**的现象，常规位锁定不起效

认定为在固定的世界三维空间的表述中坐标值的正负性是实际影响投影边界的因素

故采用视向量=>映射点坐标系，重构向量，变换(可以解释为旋转？)到视向量水平方向的坐标系

验证此变换，定义为三维前向经度锁定

> 在不断追求中学习并进步

### 目标锁定型
相较于中心环绕型，在设计目标锁定型时，查阅了更多资料，明白了很多投影知识

该投影与FOV(视场角)一同计算，将**不会产生变换偏差**

该投影逻辑为
: 获取游戏的V(经过视坐标转换)、P矩阵，合为一个转换矩阵
: 将目标坐标包装成带有距离缩放信息的向量(即四维向量，w基础值为1.0f)
: 使目标四维向量与转换矩阵相乘，得到实际V模式对应信息
: 计算并转换成屏幕坐标(包括边界框限制性取值)

由此，我彻底理解了投影转换的方法，也算是对之前思考的一个进步性回馈——我现在明白为什么会出现坐标转换问题了

将会在第三种投影完成后对第一种投影进行完全重构

> 一路走来，了解的知识越多，对未知的恐惧就越大——知识是无穷无尽的
> 
> 我们站在诸位巨人的肩膀上，并渴望着成为巨人

### 经度轴提示型
未完待续

---

早期参考信息来自：
- 吃饭时的灵光一闪
- 正交投影--维基
- 墨卡托投影--世界地图的画法
- 艾托夫、温克尔投影--AI:当今的世界地图投影方式

目标锁定型的参考信息来自：
- Unity任务指示器教程--CSDN、知乎
- M、V、P矩阵讲解--知乎
- 参与TeaCon甲辰赛事的ThatSkyInteraction模组--模组作者本人[@LouisQuepierts](https://github.com/LouisQuepierts)
- 投影概念讲解--CSDN
- 从复数到四元数--数学老师给的小科普书
- 矩阵投影的解释--AI:高中也能看得懂的数学解释(实则不然)
- 矩阵与运算--网络资源(记不住了)

感谢如此庞大的社区和丰富的、公众化的资源，让我有机会完成这样一个小型辅助模组。